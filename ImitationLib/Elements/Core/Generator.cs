using System;
using System.Collections.Generic;
using ImitationLib.Utils;

namespace ImitationLib.Elements.Core
{
	public abstract class Generator : Element, IGiver
	{
		/// <summary>
		/// Number of <see cref="Transact"/> that can be generated by this <see cref="Generator"/>
		/// </summary>
		protected virtual int Count { get; set; } = Constants.DefaultCount;

		/// <summary>
		/// Number of <see cref="Transact"/> that can be IN <see cref="Element"/>
		/// </summary>
		private new int Capacity { get; } = Constants.ZeroQueueCapacity;

		protected Generator()
		{
			this.Transacts = new Queue<Transact>(this.Capacity);
		}

		protected Generator(int delay)
		{
			this.Delay = delay;
			this.Transacts = new Queue<Transact>(this.Capacity);
		}

		protected Generator(int delay, int count)
		{
			this.Count = count;
			this.Delay = delay;
			this.Transacts = new Queue<Transact>(this.Capacity);
		}

		/// <summary>
		/// <seealso cref="IGiver.Give"/>
		/// </summary>
		/// <param name="time"></param>
		/// <returns>Given <see cref="Transact"/></returns>
		public virtual Transact Give(int time)
		{
			var transact = this.Transacts.Dequeue();
			// TODO: rename constant
			this.ReadyIn = this.Count > 0 ? this.Delay : Constants.ReadyToTake;
			transact.LifeTime = $"{transact} is given by {this} at {time}";
			return transact;
		}

		/// <summary>
		/// Generates <see cref="Transact"/>
		/// </summary>
		protected virtual void Generate(Random random = null)
		{
			var transact = new Transact(random);
			this.Transacts.Enqueue(transact);
			this.Count--;
		}

		/// <summary>
		/// <seealso cref="Element.Process"/>
		/// </summary>
		/// <param name="time"></param>
		/// <exception cref="Exception"></exception>
		public override void Process(int time)
		{
			this.Generate();
			base.Process(time);
			var temp = this.Give(time);
			try
			{
				this.Out(temp, time);
			}
			catch (Exception e)
			{
				Logger.Log.Error(e.Message);
			}
		}
	}
}